Component for decompounding words in German. Still in development phase.

= Splitters =

There are four different splitters within the de.tudarmstadt.ukp.dkpro.core.decompounding-nonfree project. Every splitter returns a [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/SplitTree.java SplitTree]. Its class diagram is shown bellow:

https://wiki.ukp.informatik.tu-darmstadt.de/pub/OpenWindow/GermanDecompounding/SplitTree_Diagram.jpg

   * [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/LeftToRightSplitter.java LeftToRightSplitter]
      * This splitter receives one word as input and returns a [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/SplitTree.java SplitTree] as output. The first thing the splitter does is to create a [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/SplitTree.java SplitTree], having a root node containing a [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/Split.java Split] with the original word as its value, in its compounding form. Then it starts to move from the left to the right, searching for a word. Whenever it finds it, it splits the word in two chunks, adds a child node containing this split and then repeats the same process for the chunk in the right. A good characteristic of this algorithm, is that it will generate all the possible splits. However, the last chunk in the right might not be an actual word. For example, for the word _geraeteelektronik_, the resulting split tree will contain nodes with the following values: : _geraeteelektronik, geraet+eelektronik, geraete+elektronik, geraete+elektr+onik, geraete+elektro+nik, geraet(e)+elektronik, geraet(e)+elektr+onik, geraet(e)+elektro+nik, geraete(e)+lektronik_
   * !BananaSplitter
   * !DataDrivenSplitter
   * [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/JWordSplitter.java JWordSplitter]
      * As the [https://scruffy.ukp.informatik.tu-darmstadt.de/svn/dkpro_ng/dkpro/core/trunk/de.tudarmstadt.ukp.dkpro.core.decompounding/src/main/java/de/tudarmstadt/ukp/dkpro/core/decompounding/splitter/LeftToRightSplitter.java LeftToRightSplitter], this splitter will also start to search for a word from the left to right, but if the right chunk is not a word, it does not generate a split, therefore, will not add a split node to the tree. After it finds words in both chunks (left and right), then it creates a split and stops. Although all the chunks in the splits generated by this algorithm are words, the bad thing is that it generates only one split. For instance, the word _geraeteelektronik_ will have as result a split tree with only two nodes: _geraeteelektronik, geraete+elektronik_

= Rankers =

Besides the splitter, 3 different rankers can also be found in the decompounding-nonfree project:

   * !FrequencyRanker
   * !MutualInformationRanker
   * !ProbabilityRanker